# Синхронизация потоков  
Атомарный Read/Write регистр - это ячейка памяти, которая поддерживает следующие операции:
write - атомарно записывает значение в регистр;
read - атомарно читает текущее значение из регистра.  
Атомарно означает, что только один поток может выполнять атомарную операцию в данный момен времени. Атомарные операции не делятся между потоками.

Атомарный регистр определяется в шаблоне std::atomic. Каждая специализация шаблона std::atomic определяет атомарный тип. Только объекты атомарных С++ типов могут безопасно использоваться в нескольких потоках одновременно. Когда один поток сохраняет данные в объекте атомарного типа, а другой хочет их прочитать, поведение программы определено стандартом.

```c++
#include <iostream>
#include <string>
#include <atomic>

int main(void) {
  // Определяем атомарный объект типа int с начальным значением 5.
  std::atomic_int obj1(5);
  // Определяем обычные переменные, доступ к которым выполняется не атомарно.
  int var1, var2;
  
  // Атомарно получаем значение, которое хранит атомарный объект obj1.
  var1 = std::atomic_load(&obj1);
  // Не атомарно изменяем значение в переменной var1;
  var1++;
  // Атомарно изменяем значение в атомарном объекте obj1 на значение 8.
  std::atomic_store(&obj1, 8);
  // В переменную var2 атомарно получаем значение, которое хранит атомарный объект obj.
  var2 = std::atomic_load(&obj1);

  std::cout << "var1 = " << var1 << " obj1 = " << var2 << std::endl;
}

/* Результат:

var1 = 6 obj1 = 8

*/
```
## Вложенность атомарных операций
Если внутри одной атомарной операции вызывается другая атомарная операция, то при выполнении исходная атомарная операция раскладывается на две атомарные операции: 
```c++
std::atomic_int a;
// Сохранить в атомарную переменную a значение полученное из атомарной переменной b.
atomic_store(&a, atomic_load(&b));

// При планировании потоков вышеприведённая операция будет разложена на следующие две атомарные операции:

// 1) Получение значения во временную атомарную переменную tmp
std::atomic_int a, tmp;
atomic_store(&tmp, atomic_load(&b));

// 2) Сохранение значения атомарной переменной tmp, полученной в шаге 1 в атомарную переменную a.
atomic_store(&a, atomic_load(&tmp));


/*

// Операции могут выполняться в разных потоках:
op1(); // Поток-0;
op2(); // Поток-0;
op1(); // Поток-1;
op2(); // Поток-1;

op1(); // Поток-0;
op1(); // Поток-1;
op2(); // Поток-0;
op2(); // Поток-1;

op1(); // Поток-1;
op1(); // Поток-0;
op2(); // Поток-0;
op2(); // Поток-1;

// и т. д.

*/

```
