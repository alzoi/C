# Удобная работа с динамическими массивами в куче

```c++
#include <iostream>

int main() {

    const int column = 2;
    
    // Создаём обычный массив, будет размещён на стеке, максимальный размер стека ограничен, около 2 МБ.
    int arr[][column] = {
        {1, 2},
        {3, 4},
        {5, 6},
        {7, 8}
    };
    
    // Выделяем в динамической памяти (heap - куче) массив из 1024 элементов int и получаем умный указатель - объект dat1.    
    int n = 512*column;
    auto dat1 = std::make_unique<int[]>(n);
    
    // Создаём тип matrix - псевдоним для указателя на массив из двух int.
    using matrix = int(*)[column];
    
    // Получаем указатель и работаем с данными как с обычным двумерным массивом.
    matrix k = (matrix)dat1.get();
    k[0][0] = 101;
    k[0][1] = 102;
    k[1][0] = 201;
    k[1][1] = 202;
    k[2][0] = 301;
    k[2][1] = 302;
    k[3][0] = 401;
    k[3][1] = 402;

    std::cout << k[0][1] << "|" << k[1][1] << std::endl;

    // Сложный способ обращения к элементу [3][1].
    int* p = (int*)dat1.get();
    int* p_el = p + column * 3 + 1;
    std::cout << *p_el << "|" << k[3][1] << std::endl;

    // В момент выхода из блока умный указатель выполнит автоматическое освобождение памяти в деструкторе dat1.
    // Явное освобождение памяти.
    dat1.reset();

    return 0;
}
```

Вывод:
```
102|202
402|402
```
